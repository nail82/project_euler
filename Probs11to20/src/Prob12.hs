module Prob12 where

import qualified Data.List as L
import qualified GHC.Float as F

{-
The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7
= 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five
divisors.

What is the value of the first triangle number to have over five
hundred divisors?
-}

{-
  A little research shows a closed form for the number
  of factors for a given number.  If you find the prime
  factorization of a number, then the total number of factors
  is the product of each prime exponent, p, plus one.

  Say the prime factorization of n = x * x * y * z,
  then the total number of factors is (3)(2)(2).

  So, it looks like a recursive search to get the
  full list of primes, a sort, a fold to
  count occurrences and then a product.

-}

run12 :: IO ()
run12 = do
  putStr "Problem 12 => "
  putStrLn $ show $ fst ans12

ans12 :: (Int, Int)
ans12 = head $ dropWhile (\n -> (snd n) < 500) $ fmap checkTri [3..]

checkTri :: Int -> (Int, Int)
checkTri n = (triNum n, (countFactors . primeFactors . triNum) n)

triNum :: Int -> Int
triNum n = (n ^ (2 :: Int) + n) `div` 2

countFactors :: [Int] -> Int
countFactors xs = foldr (*) 1 $ fmap (\ys -> 1 + length ys) $ L.group $ L.sort xs

isPerfectSquare :: Int -> Bool
isPerfectSquare x = (fromIntegral $ croot x :: Double) == (sqrt $ fromIntegral x)

croot :: Int -> Int
croot n = (ceiling . sqrt) $ (F.int2Double n)

primeFactors :: Int -> [Int]
primeFactors n = let st = case n `mod` 2 == 0 of
                            True -> MyFactor (n `div` 2, 2)
                            False -> fermatFactor n
                 in factorHelper [] st

factorHelper :: [Int] -> MyFactor -> [Int]
factorHelper xs (MyFactor (n, 1)) = n : xs
factorHelper xs (MyFactor (lhs, rhs)) =
    let ys = factorHelper xs $ fermatFactor lhs
    in factorHelper ys $ fermatFactor rhs

newtype MyFactor =
    MyFactor (Int, Int)
    deriving (Eq, Show)

fermatFactor :: Int -> MyFactor
fermatFactor 2 = MyFactor (2,1)
fermatFactor n = case n `mod` 2 == 0 of
                   True -> MyFactor (n `div` 2, 2)
                   False -> fermatSearch (croot n) n

fermatSearch :: Int -> Int -> MyFactor
fermatSearch a n = case isPerfectSquare b2 of
                     True -> let rhs = F.double2Int
                                       $ (F.int2Double a)
                                       - (sqrt $ fromIntegral b2)
                                 lhs = n `div` rhs
                             in MyFactor (lhs, rhs)
                     False -> fermatSearch (a+1) n
    where b2 = a ^ (2 :: Int) - n
